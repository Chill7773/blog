[TOC]

### 什么是表驱动法

表驱动法是一种编程模式，从表里面查找信息而不使用逻辑语句（if 和 switch 语句 ）， 让凌乱代码变得简明和清晰。

对简单情况而言，表驱动方法可能仅仅使逻辑语句更容易和直白，但随着逻辑的越来越复杂，表驱动法就愈发有吸引力。

而且表里不仅仅可以存储数据、还可以存储函数，类等数据结构或动作

### 表驱动法查询数据的方式

##### 直接访问(Direct Access)

场景：

> 比如我们想要实现一个传入`[1-7]`范围的数字来返回周一到周日字符串的函数，我可以使用 if 或 switch 语句轻松实现。但是如果是日期，不同年龄呢，难道要写上一大堆判断语句？对此我们可以使用直接访问的方式来实现

示例代码：

```ts
const formatWeek = (n: number) => {
  if (n > 7 && n < 1) return null;
  const week = ["周一", "周二", "周三", "周四", "周五", "周六", "周日"];
  return week[n - 1];
};
```

##### 索引访问（Index Access）

场景：

> 假设一个企业的员工有 200 人，员工工号是 5 位数字。如果我们需要根据工号获取信息或根据信息执行一些不同操作，使用 if 或 switch 语句是不可能的（太长）；使用直接访问的方式，需要我们建一个长度 10 万的表格，虽然可以，但是显然这个会造成极大的空间浪费。对此我们需要使用索引访问

示例代码：

```ts
const Table: {
  [key: string]: any;
} = {
  "00001": () => {
    /* 获取信息，执行相关个性化操作 */
    return {
      /* 返回相关信息 */
    };
  },
  /* 略*/
  "00100": () => {
    /* 略*/
  },

  /* 默认操作 */
  default: () => {
    /* 略*/
  },
};

/**
 * @constant 员工工号
 */
const number: string = "00200";
// 我们可以通过:
Table[number]();
// 快速执行相关操作;对于不在索引中的执行:
Table.default();
```

##### 阶梯访问(Stair-Step Access)

场景：

> 对于一个`[0~100]`的分数我们需要对不同的分数段进行评级，使用索引方法虽然可行且快，但是太浪费空间；因此我可以使用阶梯访问的方法。

示例代码：

```ts
const level = ["不及格", "一般", "中等", "良好", "优秀"];
const score_border = [60, 70, 80, 90, 100];

function getLevel(score: number) {
  const len = score_border.length;
  for (let i = 0; i < len; i++) {
    if (score <= score_border[i]) {
      return level[i];
    }
  }
  return level[len - 1];
}
```

### 表驱动法优点

- 代码更容易阅读，可以快速了解正在发生的事情。
- 修改容易、可维护性强、效率更高。
- 能够大量消除代码中 if-else， swith-case 判断。
